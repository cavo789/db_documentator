<?php

declare (strict_types = 1);

/**
 * Author: AVONTURE Christophe - https://www.avonture.be.
 *
 * Written date: 15 february 2019
 * Last mod: 28 June 2019
 *
 * This script will establish a connection to a MySQL database
 * and retrieve all tables.
 *
 * Table by table documentation will be generated:
 *
 *    - a .csv file with the first xxx records of the table
 *    - a .sql file with a simple SELECT statement on that table
 *    - a _connection.md file with the info needed for establishing a connection
 *          on the database
 *    - a _description.md file with the description of the table
 *    - a _structure.md file with a markdown table
 *          and will display the structure of the table (fieldname, type
 *          and comments if any)
 *
 * If createMarknotes setting is set to True, additional .md files will be created:
 *    - a .md file for the documentation of the database itself
 *    - one .md file by table.
 *
 * These two additional files will use a template defined in the settings.json file, under
 * marknotes->templates. Please refers to the marknotes documentation to learn more on that tool.
 *
 * @see https://github.com/cavo789/marknotes
 */

namespace Classes;

/**
 * The main class.
 */
class DbDocument
{
    private const DS = DIRECTORY_SEPARATOR;

    /**
     * Undocumented variable
     *
     * @var Classes\Csv2Md
     */
    private $csv2MdParser = null;

    /**
     * Database username to use to establish the connection.
     *
     * @var string
     */
    protected $userName = '';

    /**
     * Database password to use to establish the connection.
     *
     * @var string
     */
    protected $password = '';

    /**
     * Database name.
     *
     * @var string
     */
    protected $dbName = '';

    /**
     * Database hostname (like "localhost" f.i.).
     *
     * @var string
     */
    protected $hostName = '';

    /**
     * Type to use for the connection (can be "mysqli", "mysql", ...).
     *
     * @var string
     */
    protected $dbType = 'mysqli';

    /**
     * If a prefix is used for table's names, the prefix should be configured here.
     *
     * @var string
     */
    protected $dbPrefix = '';

    /**
     * Object to the database.
     *
     * @var [type]
     */
    private $mysqli = null;

    /**
     * Path where to save files generated by this class.
     *
     * @var string
     */
    private $outputFolder = '';

    /**
     * Timezone; needed to correctly display date/time
     * Will be initialized in the __constructor to the server's default.
     *
     * @var string
     */
    private $timezone= '';

    /**
     * Format for displaying date/time
     * Default; if not specified, will be Y-m-d h:i:s a.
     *
     * @var string
     */
    private $timeformat = 'Y-m-d h:i:s a';

    /**
     * Number of rows to show in the table samples.
     *
     * @var int
     */
    private $maxrows = 5;

    /**
     * Does this script should generate .csv files?
     *
     * @var bool
     */
    private $createCsv = true;

    /**
     * Does this script should generate .md files?
     *
     * @var bool
     */
    private $createMd = true;

    /**
     * Does this script should generate _custom.md file for tables?
     * The tablename_custom.md file will allow the documentation maintainer
     * to type extra documentation for tables.
     *
     * Note: when exporting a table, the script will check if the tablename_custom.md
     * file exists or not. If not, the file WON'T BE OVERWRITTEN so changes made by the
     * documentation maintainer won't be lost.
     *
     * @var bool
     */
    private $createCustomMd = false;

    /**
     * Does this script should generate files for marknotes?
     *
     * @var bool
     */
    private $createMarknotes = false;

    /**
     * Does this script should generate files for gitlab wiki?
     *
     * @var bool
     */
    private $createGitLabWiki = false;

    /**
     * Does this script should generate .sql files?
     *
     * @var bool
     */
    private $createSql = true;

    /**
     * Define the separator to use for CSV files.
     *
     * @var string
     */
    private $csvSeparator = ',';

    /**
     * Templates to use.
     *
     * @var array
     */
    private $templates = [];

    /**
     * Enable or not the debug mode.
     *
     * @var bool
     */
    private $debug  = false;

    /**
     * List of tables found in the database.
     * There are two entries for each table: the table name and his description (if filled in of course).
     *
     * @var array
     */
    private $arrTables = [];

    /**
     * Constructor.
     *
     * @param array $db
     *
     *   $db is initialized with a records coming from the settings.json file.
     *   $db contains, at least, the following keys:
     *       host     : Database hostname (like "localhost" f.i.)
     *       name     : Database name.
     *       user     : Database username to use to establish the connection.
     *       password : Database password to use to establish the connection.
     *       prefix   : If a prefix is used for table's names, the prefix should be
     *                      configured here.
     *       type     : Type to use for the connection (can be "mysqli", "mysql", ...)
     *
     *   and can also contains a output node with:
     *       add_custom_files : Boolean (1 or 0) to tell the class to create a
     *                      _custom.md file for each table
     *       path     : Path where to save files generated by this class
     *       url      : When the output is done, if an URL has been specified,
     *                      the script will display "Open URL" statement so it's easy
     *                      for the user to "jump" that that URL (probably the online
     *                      documentation tool)
     *
     * @param Classes\Csv2Md $csv
     *       $csv is a parser that will convert a CSV string into a MD array
     */
    public function __construct(array $db, \Classes\Csv2Md $csv)
    {
        $this->csv2MdParser = $csv;

        $this->hostName = trim($db['host']);
        $this->userName = trim($db['user']);
        $this->password = trim($db['password'] ?? '');
        $this->dbName   = trim($db['name'] ?? '');
        $this->prefix   = trim($db['prefix'] ?? 'mysqli');

        // Retrieve the default time/zone
        $this->timezone = date_default_timezone_get();

        if ('' !== trim($db['type'])) {
            $this->dbType = trim($db['type']);
        }

        if (isset($db['output'])) {
            // Get the name of the output folder (f.i. c:/christophe/output)
            $folder = trim($db['output']['folder']);

            if ('' !== $folder) {
                $folder = str_replace('/', DIRECTORY_SEPARATOR, $folder);
                self::setOutputFolder($folder);
            }
        }
    }

    /**
     * Release objects.
     */
    public function __destruct()
    {
        unset($this->mysqli);
    }

    /**
     * Enable debug mode i.e. set mysqli_report to all.
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setDebug(bool $onOff)
    {
        $this->debug = $onOff;
        if ($this->debug) {
            mysqli_report(MYSQLI_REPORT_STRICT);
        }
    }

    /**
     * Timezone; needed to correctly display date/time.
     *
     * @param string $timezone (f.i. 'Europe/Brussels')
     *
     * @return void
     */
    public function setTimeZone(string $timezone)
    {
        $this->timezone = $timezone;
        date_default_timezone_set($this->timezone);
    }

    /**
     * Format for displaying date/time.
     *
     * @param string $timeformat (f.i. 'd/m/Y H:i:s')
     *
     * @return void
     */
    public function setTimeFormat(string $timeformat)
    {
        $this->timeformat = rtrim($timeformat) . ' ';
    }

    /**
     * Number of rows to show in the table samples.
     *
     * @param int $maxrows
     *
     * @return void
     */
    public function setMaxRows(int $maxrows)
    {
        $this->maxrows = $maxrows;
    }

    /**
     * Does this script should generate .csv files?
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateCSV(bool $onOff)
    {
        $this->createCsv = $onOff;
    }

    /**
     * Does this script should generate .md files?
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateMD(bool $onOff)
    {
        $this->createMd = $onOff;
    }

    /**
     * Does this script should generate _custom.md file for tables?
     * The tablename_custom.md file will allow the documentation maintainer
     * to type extra documentation for tables.
     *
     * Note: when exporting a table, the script will check if the tablename_custom.md
     * file exists or not. If not, the file WON'T BE OVERWRITTEN so changes made by the
     * documentation maintainer won't be lost.
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateCustomMD(bool $onOff)
    {
        $this->createCustomMd = $onOff;
    }

    /**
     * Does this script should generate files for marknotes?
     *
     * @see https://github.com/cavo789/marknotes
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateMarknotes(bool $onOff)
    {
        $this->createMarknotes = $onOff;
    }

    /**
     * Does this script should generate files for gitlab wiki?
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateGitLabWiki(bool $onOff)
    {
        $this->createGitLabWiki = $onOff;
    }

    /**
     * Does this script should generate . sql files ?
     *
     * @param bool $onOff
     *
     * @return void
     */
    public function setCreateSQL(bool $onOff)
    {
        $this->createSql = $onOff;
    }

    /**
     * Define the separator to use for CSV files.
     *
     * @param string $separator (f.i. ";")
     *
     * @return void
     */
    public function setCSVSeparator(string $separator)
    {
        $separator          = trim($separator);
        $this->csvSeparator = ('' == $separator ? ',' : $separator);
    }

    /**
     * Set templates.
     *
     * @param array $data
     *
     * @return void
     */
    public function setTemplates(array $data)
    {
        $this->templates = $data;
    }

    /**
     * Information's coming from the settings file for GitLab wiki usage
     * The array will contains a.o.t. templates to use.
     *
     * @param array $data
     *
     * @return void
     */
    public function setGitLabWiki(array $data)
    {
        $this->gitLabWiki = $data;
    }

    /**
     * Try to connect to the database. Return False in case of failure.
     *
     * @return bool
     */
    public function init(): bool
    {
        $bError = false;

        try {
            $this->mysqli = new \mysqli(
                self::hostName(),
                self::userName(),
                self::password(),
                self::dbName()
            );

            if (0 !== $this->mysqli->connect_errno) {
                $bError = true;
                //@TODO Better managed DB connection's failure
                echo 'Could not connect to mysql; error #' .
                    $this->mysqli->connect_errno . ' - ' . $this->mysqli->connect_error;
            }

            //self::debug('init() - Connection established');

            // Make sure accentuated characters will be correctly handled
            $this->mysqli->set_charset('utf8');

            self::populateTableList();
        } catch (\Exception $e) {
            //@TODO Better managed DB connection's failure
            $bError  = true;
        }

        // if false then no error encountered; success
        return false == $bError;
    }

    /**
     * Return a HTML string to display the used' credentials.
     *
     * @return string
     */
    public function getHTMLCredentials(): string
    {
        if ($this->createMarknotes) {
            // Create the dbname_connection.md file that will be used in the
            // marknotes's database template
            $content =
                '* Host name: ' . self::hostName() . PHP_EOL .
                '* Type: ' . self::dbType() . PHP_EOL .
                '* Username: ' . self::userName() . PHP_EOL .
                '* Password: ' . self::password() . PHP_EOL .
                '* Table prefix: ' . self::dbPrefix() . PHP_EOL;

            self::makeFile(self::dbName() . '_connection.md', $content, 'tables/.files');
        }

        return
            '<ul>' .
            '<li>Host : ' . self::hostName() . '</li>' .
            '<li>Type : ' . self::dbType() . '</li>' .
            '<li>Database : ' . self::dbName() . '</li>' .
            '<li>Username : ' . self::userName() . '</li>' .
            '<li>Password : ' . self::password() . '</li>' .
            '<li>Prefix : ' . self::dbPrefix() . '</li>' .
            '</ul>';
    }

    /**
     * Process the recordset and return a <table>...</table> DOM element with
     * the list of tables and record's count by table.
     *
     * @return string
     */
    public function getListOfTables(): string
    {
        // Retrieve the list of all tables in the database so we can then loop
        $sSQL = 'SELECT * FROM INFORMATION_SCHEMA.TABLES ' .
            "WHERE TABLE_SCHEMA LIKE '" . self::dbName() . "' ORDER BY TABLE_NAME;";

        $sTocTables = '';
        $i          = 0;

        if ($rows = $this->mysqli->query($sSQL)) {
            $sReturn = '<pre><code class="language-sql">' . $sSQL . '</code></pre>';

            $sReturn .= '<table id="tbl" class="table tablesorter table-hover ' .
                'table-bordered table-striped">' .
                '<thead><td>TableName</td><td># rows</td><td>Description</td></thead>' .
                '<tbody>';

            $sCSV =
                'name' . $this->csvSeparator .
                'rows' . $this->csvSeparator .
                'comment' .
                PHP_EOL;

            while ($row = $rows->fetch_array()) {
                if ($this->createGitLabWiki) {
                    // Get the list of tables as an ordered list
                    // This for the table of contents ("List of tables")
                    ++$i;
                    $sTocTables .= $i . '. [' . $row['TABLE_NAME'] . ']' .
                        '(./tables/' . $row['TABLE_NAME'] . ')' . PHP_EOL;
                }

                $sReturn .= '<tr>' .
                    '<td>' . $row['TABLE_NAME'] . '</td>' .
                    '<td>' . $row['TABLE_ROWS'] . '</td>' .
                    '<td>' . $row['TABLE_COMMENT'] . '</td>' .
                    '</tr>';

                $sComment = $row['TABLE_COMMENT'];
                $sComment = str_replace(';', ',', $sComment);
                $sComment = str_replace('|', '<br/>', $sComment);

                $sCSV .=
                    $row['TABLE_NAME'] . $this->csvSeparator .
                    $row['TABLE_ROWS'] . $this->csvSeparator .
                    $sComment .
                    PHP_EOL;
            }

            $sReturn .= '</tbody></table>';

            // Generate a xxx_tables.csv file with the list of tables
            if ($this->createCsv) {
                self::makeFile(self::dbName() . '_tables.csv', $sCSV, 'tables/.files');
            }

            if (($this->createGitLabWiki) || ($this->createMarknotes)) {
                $sTocTables .= PHP_EOL;

                self::makeFile(
                    self::dbName() . '.md',
                    self::template(
                        'database',
                        ['tables_list'=> $sTocTables]
                    )
                );
            }

            if ($this->createMd && $this->createCustomMd) {
                // The dbName()_custom.md file will allow the documentation maintainer
                // to add extra information's to the database's documentation.
                // Such files won't be overwritten if already there.
                self::makeFile(self::dbName() . '_custom.md', '', 'tables/.files', true);
            }
        }

        return $sReturn;
    }

    /**
     * Process every tables and, one by one, display detailed information's like
     *     - A SELECT * FROM SQL string
     *     - The first xxx records (based on the $this->maxrows constant).
     *
     * @return string
     */
    public function getTablesDetail(): string
    {
        $sReturn = '';

        if (count($this->arrTables) > 0) {
            foreach ($this->arrTables as $key => $table) {
                $tableName        = $table[0];
                $tableDescription = $table[1];
                $tableDescription = str_replace('|', PHP_EOL, $tableDescription);

                // Generate a _description.md file with the table description
                if (($this->createMarknotes) && ($this->createMd)) {
                    self::makeFile($tableName . '_description.md', $tableDescription, 'tables/.files');
                }

                if ($this->createMarknotes && $this->createCustomMd) {
                    // The xxx_custom.md file will allow the documentation maintainer
                    // to add extra information's to the table's documentation.
                    // Such files won't be overwritten if already there.
                    self::makeFile($tableName . '_custom.md', '', 'tables/.files', true);
                }

                $sSQL = 'SELECT * FROM `' . self::dbName() . '`.`' . $tableName . '`;';

                // Generate a .sql file with a simple SELECT command
                if (($this->createMarknotes) && ($this->createSql)) {
                    self::makeFile($tableName . '.sql', $sSQL, 'tables/.files');
                }

                if ($this->createMarknotes) {
                    $arr               =[];
                    $arr['table_name'] = $tableName;
                    self::makeFile($tableName . '.md', self::template('table', $arr), 'tables');
                }

                $sReturn .= '<h3 id="' . $tableName . '">' . $tableName . '</h3>';
                $sReturn .= '<p>' . $tableDescription . '</p>';
                $sReturn .= '<h4>SQL</h4>';
                $sReturn .= '<pre><code class="language-sql">' . $sSQL . '</code></pre>';

                $sReturn .= '<h4>Samples</h4>';
                $sSampleRows = self::getFirstRows($tableName);
                $sReturn .= $sSampleRows;

                $sReturn .= '<h4>Table structure</h4>';
                $tableStructure = self::getTableStructure($tableName);
                $sReturn .= $tableStructure . '<hr/>';

                $sReturn .= '<h4>Table relations</h4>';
                $sRelations = self::getTableRelations($tableName);
                $sReturn .= $sRelations . '<hr/>';

                if ($this->createGitLabWiki) {
                    $arr                      =[];
                    $arr['table_name']        = $tableName;
                    $arr['table_description'] = $tableDescription;
                    $arr['table_structure']   = trim($tableStructure, ' \n');

                    if ('' !== $sSampleRows) {
                        // Create a new CSV parser
                        $this->csv2MdParser->setCSV($sSampleRows);
                        $this->csv2MdParser->setDelimiter(';');

                        $sSampleRows = $this->csv2MdParser->getMarkup();
                    }

                    $arr['sample_rows'] = $sSampleRows;

                    $arr['relations']   = $sRelations;

                    self::makeFile($tableName . '.md', self::template('table', $arr), 'tables');
                }
            }
        }

        return $sReturn;
    }

    /**
     * Define the output path i.e. where this class can store files.
     *
     * @param string $path
     *
     * @return void
     */
    private function setOutputFolder(string $path)
    {
        $path = trim($path, '/\\');
        $path .= DIRECTORY_SEPARATOR;

        if (!is_dir($path)) {
            mkdir($path, 0755);

            $f = fopen($path . '.htaccess', 'w');
            fwrite($f, "# This folder shouldn't be accessible\nDeny from all");
            fclose($f);
        }

        $this->outputFolder = $path;
    }

    /**
     * Create a file on disk; in the output folder.
     *
     * @param string $filename      Basename of the file (no path)
     * @param string $content       The file's content
     * @param string $subfolder     Sub-folder where to put the file
     * @param bool   $onlyIfMissing Create the file only if not yet present.
     *                              Do nothing if the file already exists
     *
     * @return void
     */
    private function makeFile(
        string $filename,
        string $content,
        string $subfolder = '',
        bool   $onlyIfMissing = false
    ) {
        // Get the output folder
        $path = rtrim(self::outputFolder(), self::DS) . self::DS;

        // The file to create will be used by marknotes so create
        // it in the specified sub-folder
        if (($this->createMarknotes) || ($this->createGitLabWiki)) {
            $path .= $subfolder . self::DS;
            if (!is_dir($path)) {
                mkdir($path, 0755, true);
            }
        }

        $bContinue = true;

        if ($onlyIfMissing) {
            // If the file already exists; don't continue.
            // Only if missing i.e. create the file only if not yet present
            $bContinue = !(file_exists($path . $filename));
        }

        if ($bContinue) {
            // Create the file
            $f = fopen($path . $filename, 'w');
            fwrite($f, $content);
            fclose($f);
        }
    }

    /**
     * Get the table structure.
     *
     * @param string $tableName
     *
     * @return string
     */
    private function getTableStructure(string $tableName): string
    {
        $sReturn = '';

        $sSQL = 'SHOW FULL COLUMNS FROM `' . self::dbName() . '`.`' . $tableName . '`';

        if ($rows = $this->mysqli->query($sSQL)) {
            $sReturn = '| FieldName | Type | Key | Nullable | Comment |' . PHP_EOL .
                '| --- | --- | --- | --- | --- |' . PHP_EOL;

            foreach ($rows as $col) {
                $key = '';

                // Is the field is part of a key?
                if (isset($col['Key'])) {
                    switch (strtolower(trim($col['Key']))) {
                        case 'mul':
                            $key = 'Multiple';

                            break;
                        case 'pri':
                            $key = 'Primary';

                            break;
                        case 'uni':
                            $key = 'Unique';

                            break;
                        default:
                            $key = $col['Key'];

                            break;
                    }
                }

                $sReturn .= '| `' . $col['Field'] . '` | ' . $col['Type'] . ' | ' .
                    $key . ' | ' . strtolower($col['Null']) . ' | ' . $col['Comment'] . ' |' . PHP_EOL;
            }

            // Generate a .md file with the structure of the table
            if (($this->createMarknotes) && ($this->createMd)) {
                $sReturn = '*Last update: ' . date($this->timeformat, time()) . '*' .
                    PHP_EOL . PHP_EOL . $sReturn;

                self::makeFile($tableName . '_structure.md', $sReturn, 'tables/.files');
            }
        }

        if (!$this->createGitLabWiki) {
            $sReturn = '<pre>' . $sReturn . '</pre>';
        }

        return trim($sReturn, ' \n');
    }

    /**
     * Get the list of relations between tables (thanks to foreign keys).
     *
     * Note: running this SQL is slow...
     *
     * @param string $tableName
     *
     * @return string
     */
    private function getTableRelations(string $tableName): string
    {
        $sSQL =
            'select fks.table_name as fk_tableName, ' .
            'group_concat(kcu.column_name order by ' .
                "position_in_unique_constraint separator ', ') as fk_columns, " .
            "'->' as rel, " .
            'fks.referenced_table_name as pk_tableName,  ' .
            'kcu.referenced_column_name as pk_column ' .
            'from information_schema.referential_constraints fks  ' .
            'join information_schema.key_column_usage kcu  ' .
            'on fks.constraint_schema = kcu.table_schema and  ' .
            'fks.table_name = kcu.table_name and  ' .
            'fks.constraint_name = kcu.constraint_name  ' .
            "where fks.constraint_schema = '" . self::dbName() . "' " .
            "and fks.table_name = '" . $tableName . "' " .
            'group by fks.constraint_schema, fks.table_name,  ' .
                'fks.unique_constraint_schema, fks.referenced_table_name,  ' .
            'fks.constraint_name , kcu.referenced_column_name ' .
            'order by fk_tableName, fk_columns;';

        $sReturn = '';

        if ($rows = $this->mysqli->query($sSQL)) {
            $sReturn = '| TableName | Column | Relation | Primary table | Primary colum | ' . PHP_EOL .
                '| --- | --- | --- | --- | --- | ' . PHP_EOL;

            foreach ($rows as $col) {
                $sReturn .= '| ' .
                    $col['fk_tableName'] . ' | ' .
                    $col['fk_columns'] . ' | ' .
                    $col['rel'] . ' | ' .
                    $col['pk_tableName'] . ' | ' .
                    $col['pk_column'] . ' |' .
                     PHP_EOL;
            }
        }

        if (!$this->createGitLabWiki) {
            $sReturn = '<pre>' . $sReturn . '</pre>';
        }

        return $sReturn;
    }

    /**
     * Process the recordset: rows in a specific table.
     *
     * @param mysqli_result $rows
     * @param string        $filename
     *
     * @return string
     */
    private function makeCSV(\mysqli_result $rows, string $filename): string
    {
        // Should we create a .csv file on disk or not?
        if (!$this->createCsv) {
            $filename = 'php://memory';
        }

        $f = fopen($filename, 'wt');

        // First row to process, the row with fieldnames
        $headerRow = true;

        // Loop all rows and generate the CSV content
        while ($row = $rows->fetch_assoc()) {
            if ($headerRow) {
                // Get the header row i.e. fieldnames
                fputcsv($f, array_keys($row), $this->csvSeparator);
                $headerRow = false;
            }

            fputcsv($f, $row, $this->csvSeparator);
        }

        // Get the first rows of the file
        // Use "+1" because the first line is the row with column's heading
        if ($this->createCsv) {
            $firstRows = implode('', array_slice(file($filename), 0, $this->maxrows + 1));
        } else {
            // Special case since the file wasn't created on disk but on memory
            rewind($f);

            ob_start();
            fpassthru($f);
            $firstRows = ob_get_contents();
            ob_end_clean();
        }

        fclose($f);

        return $firstRows;
    }

    /**
     * Get the first xxx rows of the table and display them on screen
     * If the $this->createCsv constant is set to true, output a .csv
     * file into the OUTPUT folder.
     *
     * @param string $tblName
     *
     * @return string
     */
    private function getFirstRows(string $tableName): string
    {
        $sReturn = '';

        $sSQL = 'SELECT * FROM `' . self::dbName() . '`.`' . $tableName . '` LIMIT ' . $this->maxrows;

        if ($rows = $this->mysqli->query($sSQL)) {
            // Generate a CSV file and get his content so we can display it

            $path = $this->outputFolder . ($this->createMarknotes ? 'tables/.files' . self::DS : '');
            $CSV  = self::makeCSV($rows, $path . $tableName . '.csv');

            if (!$this->createMd) {
                if ('' === $CSV) {
                    $sReturn .= '<div>The table is empty.</div>';
                } else {
                    $sReturn .= '<pre>' . $CSV . '</pre>';
                }
            } else {
                $sReturn .= $CSV;
            }
        }

        return $sReturn;
    }

    /**
     * Retrieve the list of all tables in the database and initialize the $arrTables
     * variable.
     *
     * @return void
     */
    private function populateTableList()
    {
        //self::debug('populateTableList() called');

        $this->arrTables = null;

        $sSQL = 'SELECT * FROM INFORMATION_SCHEMA.TABLES ' .
            "WHERE TABLE_SCHEMA LIKE '" . self::dbName() . "' ORDER BY TABLE_NAME;";

        if ($rows = $this->mysqli->query($sSQL)) {
            while ($row = $rows->fetch_array()) {
                $this->arrTables[] = [$row['TABLE_NAME'], $row['TABLE_COMMENT']];
            }
        }
    }

    /**
     * Show a debug message when running with debug mode set.
     *
     * @param string $line
     *
     * @return void
     */
    private function debug(string $line)
    {
        if ($this->debug) {
            echo '<em>DebugMode - ' . $line . '</em><br/>';
        }
    }

    /**
     * Get the database host.
     *
     * @return string
     */
    private function hostName(): string
    {
        return $this->hostName;
    }

    /**
     * Get the database name.
     *
     * @return string
     */
    private function dbName(): string
    {
        return $this->dbName;
    }

    /**
     * Get the database user name.
     *
     * @return string
     */
    private function userName(): string
    {
        return $this->userName;
    }

    /**
     * Get the password to use for making a connection to the database.
     *
     * @return string
     */
    private function password(): string
    {
        return $this->password;
    }

    /**
     * Return the table's prefix if there is one.
     *
     * @return string
     */
    private function dbPrefix(): string
    {
        return $this->dbPrefix;
    }

    /**
     * Return the database type (f.i. "mysqli").
     *
     * @return string
     */
    private function dbType(): string
    {
        return $this->dbType;
    }

    /**
     * Path where to save files generated by this class.
     *
     * @return string
     */
    private function outputFolder(): string
    {
        return $this->outputFolder;
    }

    /**
     * Get a template.
     *
     * @param string $sName     Name of the template to return
     * @param array  $variables Array with extra name like TABLE_NAME and their values
     *
     * @return string
     */
    private function template(string $sName, array $variables = []): string
    {
        $tmpl = '';

        if (isset($this->templates[$sName])) {
            $tmpl = $this->templates[$sName] ?? '';

            if (is_array($tmpl)) {
                $tmpl = implode(PHP_EOL, $tmpl);
            }

            if ('' !== $tmpl) {
                $tmpl = str_replace('@@DB_NAME@@', self::dbName(), $tmpl);

                $tmpl = str_replace('@@LASTUPDATE@@', 'Last update: ' .
                    date($this->timeformat, time()), $tmpl);

                if (count($variables) > 0) {
                    foreach ($variables as $name => $value) {
                        $tmpl = str_replace('@@' . strtoupper($name) . '@@', $value, $tmpl);
                    }
                }
            }
        }

        return $tmpl;
    }
}
